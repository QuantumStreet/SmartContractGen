{{!-- Scrypto Smart Contract Template --}}
{{!-- License and package info --}}
{{#if license}}
    // Licensed under {{{license}}}
{{/if}}

{{#if edition}}
    use scrypto::prelude::*;
{{else}}
    use scrypto::prelude::*;
{{/if}}

{{#if imports}}
    {{#each imports}}
        use {{{this}}};
    {{/each}}
{{/if}}

{{!-- Blueprint definition --}}
{{#if (eq blueprintType "Blueprint")}}
    {{#if description}}
        /// {{{description}}}
    {{else}}
        /// {{{name}}} blueprint implementation
    {{/if}}
    #[blueprint]
    {{#if features}}
        #[types(
        {{#each features}}
            {{{this}}}{{#unless @last}}, {{/unless}}
        {{/each}}
        )]
    {{/if}}
    mod {{{name.toLowerCase}}} {
    {{#if enableAuth}}
        enable_method_auth! {
        {{#if authMethods}}
            {{#each authMethods}}
                methods {
                {{#each methods}}
                    {{{name}}} => {{{auth}}};
                {{/each}}
                }
            {{/each}}
        {{else}}
            methods {
            instantiate => restrict_to: [OWNER];
            deposit => PUBLIC;
            withdraw => restrict_to: [OWNER];
            }
        {{/if}}
        }
    {{/if}}

    {{#if structs}}
        // ================ Structs ================
        {{#each structs}}
            {{#if description}}
                /// {{{description}}}
            {{/if}}
            #[derive(ScryptoSbor{{#if additional_derives}}, {{#each additional_derives}}{{{this}}}{{#unless @last}}, {{/unless}}{{/each}}{{/if}})]
            pub struct {{{name}}} {
            {{#each fields}}
                {{#if description}}
                    /// {{{description}}}
                {{/if}}
                pub {{{name}}}: {{{type}}},
            {{/each}}
            }
        {{/each}}
    {{/if}}

    {{#if enums}}
        // ================ Enums ================
        {{#each enums}}
            {{#if description}}
                /// {{{description}}}
            {{/if}}
            #[derive(ScryptoSbor{{#if additional_derives}}, {{#each additional_derives}}{{{this}}}{{#unless @last}}, {{/unless}}{{/each}}{{/if}})]
            pub enum {{{name}}} {
            {{#each variants}}
                {{#if description}}
                    /// {{{description}}}
                {{/if}}
                {{{name}}}{{#if fields}}({{#each fields}}{{{this}}}{{#unless @last}}, {{/unless}}{{/each}}){{/if}},
            {{/each}}
            }
        {{/each}}
    {{/if}}

    {{#if events}}
        // ================ Events ================
        {{#each events}}
            {{#if description}}
                /// {{{description}}}
            {{/if}}
            #[derive(ScryptoSbor, ScryptoEvent)]
            pub struct {{{name}}} {
            {{#each fields}}
                {{#if description}}
                    /// {{{description}}}
                {{/if}}
                pub {{{name}}}: {{{type}}},
            {{/each}}
            }
        {{/each}}
    {{/if}}

    struct {{{name}}} {
    {{#if state}}
        // ================ State Variables ================
        {{#each state}}
            {{#if description}}
                /// {{{description}}}
            {{/if}}
            {{{name}}}: {{{type}}},
        {{/each}}
    {{else}}
        // Sample state variable
        sample_vault: Vault,
    {{/if}}
    }

    impl {{{name}}} {
    {{#if instantiate}}
        // ================ Instantiate Function ================
        {{#if instantiate.description}}
            /// {{{instantiate.description}}}
        {{else}}
            /// Instantiates a new {{{name}}} component
        {{/if}}
        {{#if instantiate.params}}
            {{#each instantiate.params}}
                /// * `{{{name}}}` - {{{description}}}
            {{/each}}
        {{/if}}
        pub fn instantiate(
        {{#if instantiate.params}}
            {{#each instantiate.params}}
                {{{name}}}: {{{type}}}{{#unless @last}},{{/unless}}
            {{/each}}
        {{/if}}
        ) -> Global<{{{name}}}> {
        {{#if instantiate.body}}
            {{#each instantiate.body}}
                {{{this}}}
            {{/each}}
        {{else}}
            // Default instantiation logic
            Self {
            sample_vault: Vault::new(XRD),
            }
            .instantiate()
            .prepare_to_globalize(OwnerRole::None)
            .globalize()
        {{/if}}
        }
    {{else}}
        /// Instantiates a new {{{name}}} component
        pub fn instantiate() -> Global<{{{name}}}> {
        Self {
        sample_vault: Vault::new(XRD),
        }
        .instantiate()
        .prepare_to_globalize(OwnerRole::None)
        .globalize()
        }
    {{/if}}

    {{#if methods}}
        // ================ Methods ================
        {{#each methods}}
            {{#if description}}
                /// {{{description}}}
            {{else}}
                /// {{{name}}} method implementation
            {{/if}}
            {{#if params}}
                {{#each params}}
                    /// * `{{{name}}}` - {{{description}}}
                {{/each}}
            {{/if}}
            {{#if returns}}
                /// Returns: {{{returns.description}}}
            {{/if}}
            pub fn {{{name}}}(
            &mut self{{#if params}},{{/if}}
            {{#if params}}
                {{#each params}}
                    {{{name}}}: {{{type}}}{{#unless @last}},{{/unless}}
                {{/each}}
            {{/if}}
            ){{#if returns}} -> {{{returns.type}}}{{/if}} {
            {{#if body}}
                {{#each body}}
                    {{{this}}}
                {{/each}}
            {{else}}
                {{#if (eq visibility "public")}}
                    // Public method implementation
                    info!("{{{name}}} method called");
                    {{#if returns}}
                        // Return default value - replace with actual logic
                        Default::default()
                    {{/if}}
                {{else}}
                    // Method implementation
                    {{#if returns}}
                        // Return implementation
                        Default::default()
                    {{/if}}
                {{/if}}
            {{/if}}
            }

        {{/each}}
    {{/if}}
    }
    }
{{else}}

{{!-- Package definition for multiple blueprints --}}
    {{#if (eq blueprintType "Package")}}
        {{#if description}}
            /// {{{description}}}
        {{else}}
            /// {{{name}}} package with multiple blueprints
        {{/if}}

        {{#if blueprints}}
            {{#each blueprints}}
                #[blueprint]
                mod {{{name.toLowerCase}}} {
                struct {{{name}}} {
                {{#if state}}
                    {{#each state}}
                        {{{name}}}: {{{type}}},
                    {{/each}}
                {{else}}
                    sample_vault: Vault,
                {{/if}}
                }

                impl {{{name}}} {
                pub fn instantiate() -> Global<{{{name}}}> {
                Self {
                {{#if state}}
                    {{#each state}}
                        {{{name}}}: {{{defaultValue}}},
                    {{/each}}
                {{else}}
                    sample_vault: Vault::new(XRD),
                {{/if}}
                }
                .instantiate()
                .prepare_to_globalize(OwnerRole::None)
                .globalize()
                }

                {{#if methods}}
                    {{#each methods}}
                        pub fn {{{name}}}(&mut self{{#if params}}, {{#each params}}{{{name}}}: {{{type}}}{{#unless @last}}, {{/unless}}{{/each}}{{/if}}){{#if returns}} -> {{{returns}}}{{/if}} {
                        {{#if body}}
                            {{#each body}}
                                {{{this}}}
                            {{/each}}
                        {{else}}
                            // Method implementation
                            {{#if returns}}
                                Default::default()
                            {{/if}}
                        {{/if}}
                        }
                    {{/each}}
                {{/if}}
                }
                }

            {{/each}}
        {{/if}}
    {{else}}

    {{!-- Component Template --}}
        {{#if (eq blueprintType "Component")}}
            {{#if description}}
                /// {{{description}}}
            {{else}}
                /// {{{name}}} component implementation
            {{/if}}
            use scrypto::prelude::*;

            #[derive(ScryptoSbor, NonFungibleData)]
            pub struct {{{name}}}Data {
            {{#if componentData}}
                {{#each componentData}}
                    {{#if description}}
                        /// {{{description}}}
                    {{/if}}
                    pub {{{name}}}: {{{type}}},
                {{/each}}
            {{else}}
                pub name: String,
                pub description: String,
            {{/if}}
            }

            #[blueprint]
            mod {{{name.toLowerCase}}}_component {
            struct {{{name}}}Component {
            {{#if state}}
                {{#each state}}
                    {{#if description}}
                        /// {{{description}}}
                    {{/if}}
                    {{{name}}}: {{{type}}},
                {{/each}}
            {{else}}
                admin_badge: Vault,
                component_vault: Vault,
            {{/if}}
            }

            impl {{{name}}}Component {
            pub fn instantiate() -> (Global<{{{name}}}Component>, Bucket) {
                let admin_badge = ResourceBuilder::new_fungible(OwnerRole::None)
                .divisibility(DIVISIBILITY_NONE)
                .metadata(metadata!(
                init {
                "name" => "Admin Badge", locked;
                "symbol" => "ADMIN", locked;
                }
                ))
                .mint_initial_supply(1);

                let component = Self {
            {{#if state}}
                {{#each state}}
                    {{{name}}}: {{{defaultValue}}},
                {{/each}}
            {{else}}
                    admin_badge: Vault::new(admin_badge.resource_address()),
                    component_vault: Vault::new(XRD),
            {{/if}}
                }
                .instantiate()
                .prepare_to_globalize(OwnerRole::None)
                .globalize();

                (component, admin_badge)
                }

            {{#if methods}}
                {{#each methods}}
                    {{#if description}}
                            /// {{{description}}}
                    {{/if}}
                        pub fn {{{name}}}(&mut self{{#if params}}, {{#each params}}{{{name}}}: {{{type}}}{{#unless @last}}, {{/unless}}{{/each}}{{/if}}){{#if returns}} -> {{{returns}}}{{/if}} {
                    {{#if body}}
                        {{#each body}}
                            {{{this}}}
                        {{/each}}
                    {{else}}
                            // Implementation here
                        {{#if returns}}
                                Default::default()
                        {{/if}}
                    {{/if}}
                        }

                {{/each}}
            {{/if}}
                }
                }
        {{/if}}
    {{/if}}
{{/if}}

{{#if tests}}
        // ================ Tests ================
        #[cfg(test)]
        mod tests {
        use super::*;
        use scrypto_test::prelude::*;

    {{#each tests}}
        {{#if description}}
                /// {{{description}}}
        {{/if}}
            #[test]
            fn {{{name}}}() {
        {{#if body}}
            {{#each body}}
                {{{this}}}
            {{/each}}
        {{else}}
                // Test implementation
                let mut ledger = LedgerSimulatorBuilder::new().build();
                let (public_key, _private_key, account) = ledger.new_allocated_account();

                // Add test logic here
                assert!(true);
        {{/if}}
            }

    {{/each}}
        }
{{/if}}
